
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Paul Khuong: some Lisp</title>
  <meta name="author" content="Paul Khuong">
  <meta name="description" content="Paul Khuong's personal blog. Some Lisp, some optimisation, mathematical or computer.">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://www.pvk.ca/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Paul Khuong: some Lisp" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Poller+One&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Germania+One&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fontdiner+Swanky&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Lato&subset=latin-ext&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Cardo&subset=latin-ext&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Sorts+Mill+Goudy&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=EB+Garamond&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Della+Respira&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=UnifrakturMaguntia&subset=all&display=fallback" rel="stylesheet" type="text/css">
<link href='//fonts.googleapis.com/css?family=Arimo|EB+Garamond|PT+Sans+Caption&subset=latin,cyrillic&display=fallback' rel='stylesheet' type='text/css'>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  TeX: {
    Macros: {
     sp: "^",
     sb: "_"
    }
  }});
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<meta name="twitter:dnt" content="on">

</head>

<body >
  <header role="banner"><hgroup>
  <h1><a href="/">Paul Khuong: some Lisp</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/Blog/archives">Archives</a></li>
  <li><a href="/atom.xml" title="subscribe via RSS">RSS</a></li>
</ul>

<br>

      
        <form action="https://google.com/search" method="get">
          <fieldset role="search">
            <input type="hidden" name="q" value="site:https://www.pvk.ca" />
      
      
            <input class="search" type="text" name="q" results="0" placeholder="Search" aria-label="Search"/>
          </fieldset>
        </form>
  
</nav>
  <div id="main">
    <div id="content">
      
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" style="font-family: "><a href="/Blog/2021/05/14/baseline-implementations-should-be-predictable/">Baseline implementations should be predictable</a></h1>
    
    
      <p class="meta">
        





May
  
14th, 
2021




        
         | <a href="/Blog/2021/05/14/baseline-implementations-should-be-predictable/#disqus_thread"
              data-disqus-identifier="https://www.pvk.ca/Blog/2021/05/14/baseline-implementations-should-be-predictable/"
	      >Comments</a>
        
        
      </p>
    
  </header>



  <div class="entry-content" style="font-family: ; font-size: "><p>I wrote <a href="https://crates.io/crates/reciprocal">Reciprocal</a> because I
couldn’t find a nice implementation of div-by-mul in Rust without
data-dependent behaviour. Why do I care?</p>

<p>Like <a href="https://ridiculousfish.com/blog/posts/benchmarking-libdivide-m1-avx512.html">ridiculous fish mentions in his review of divisions on M1 and AVX 512</a>,
certain divisors (those that lose a lot of precision when rounding up
to a fraction of the form \(n / 2^k\)) need a different, slower,
code path in classic implementations. Powers of two typically also
need a different code path, but at least divert to a faster sequence,
a variable right shift.</p>

<p>Reciprocal instead uses the same code path to implement two similar
expressions that only differ in the presence or absence of a
saturating increment; rather than branching, the code
increments by 1 or 0.  The upshot: predictable improvements
over hardware division, even when dividing by different
constants.</p>

<p>Summary of the results below: on my i7 7Y75 @ 1.3 GHz, reciprocal
consistently needs 1.3 ns per division, while hardware division can
only achieve ~9.6 ns / division (reciprocal needs 13.5% as much /
86.5% less time).  This looks comparable to the
<a href="https://ridiculousfish.com/blog/posts/benchmarking-libdivide-m1-avx512.html#:~:text=intel%20xeon%203.0%20ghz%20(8275cl)">results reported by fish for libdivide when dividing by 7</a>.
Fish’s <a href="https://github.com/ridiculousfish/libdivide">libdivide</a> no
doubt does better on nicer divisors, especially powers of two, but
it’s good to know that a simple implementation comes close.</p>

<p>We’ll also see that, in Rust land, the
<a href="https://crates.io/crates/fastdivide">fast_divide crate</a>
is dominated by <a href="https://github.com/ejmahler/strength_reduce">strength_reduce</a>,
and that strength_reduce is only faster than <a href="https://github.com/pkhuong/reciprocal/">reciprocal</a>
when dividing by powers of two.</p>

<p>First, results for division with the same precomputed inverse.  The
timings are from
<a href="https://github.com/bheisler/criterion.rs">criterion.rs</a>, for
\(10^4\) divisions in a tight loop.</p>

<ul>
  <li>“Hardware” is a regular HW DIV,</li>
  <li>“compiled” lets LLVM generate specialised code,</li>
  <li>“reciprocal” is <a href="https://github.com/pkhuong/reciprocal/blob/d591c59044b3a4f662112aae73c3adae9f168ea6/src/lib.rs#L11">PartialReciprocal</a>,<sup id="fnref:why-partial" role="doc-noteref"><a href="#fn:why-partial" class="footnote" rel="footnote">1</a></sup></li>
  <li>“strength_reduce” is the <a href="https://github.com/ejmahler/strength_reduce">strength_reduce crate’s u64 division</a>,</li>
  <li>and fast_divide is <a href="https://crates.io/crates/fastdivide">the fast_divide crate’s u64 division</a>.</li>
</ul>

<p>The last two options are the crates I considered before writing
reciprocal.  The strength_reduce crate switches between a special
case for powers of two (implemented as a bitscan and a shift), and a
general slow path that handles everything with a 64.64 (128 bit) fixed
point reciprocal multiplier.  fast_divide says it’s inspired by
libdivide, so I assume it implements the same three paths: a fast
path for powers of two (shift right), a slow path for reciprocal
multipliers that need one more bit than the word size (e.g, division
by 7), and a regular round-up div-by-mul sequence.</p>

<p>Let’s look at <a href="https://github.com/pkhuong/reciprocal/blob/34008e4aa1221012f82dc72b10ff1f9cbd419729/benches/div_throughput.rs">the three cases in that order</a>.</p>

<p>\(10^4\) divisions by 2 (i.e., a mere shift right by 1)</p>

<pre><code>hardware_u64_div_2      time:   [92.297 us 95.762 us 100.32 us]
compiled_u64_div_by_2   time:   [2.3214 us 2.3408 us 2.3604 us]
reciprocal_u64_div_by_2 time:   [12.667 us 12.954 us 13.261 us]
strength_reduce_u64_div_by_2
                        time:   [2.8679 us 2.9190 us 2.9955 us]
fast_divide_u64_div_by_2
                        time:   [2.7467 us 2.7752 us 2.8025 us]
</code></pre>

<p>This is the <em>comparative</em> worst case for reciprocal: while reciprocal
always uses the same code path (1.3 ns/division), the compiler shows
we can do much better with a right shift. Both branchy implementations
include a special case for powers of two, and thus come close to the
compiler, thanks a predictable branch into a right shift.</p>

<p>\(10^4\) divisions by 7 (a “hard” division)</p>

<pre><code>hardware_u64_div_7      time:   [95.244 us 96.096 us 97.072 us]
compiled_u64_div_by_7   time:   [10.564 us 10.666 us 10.778 us]
reciprocal_u64_div_by_7 time:   [12.718 us 12.846 us 12.976 us]
strength_reduce_u64_div_by_7
                        time:   [17.366 us 17.582 us 17.827 us]
fast_divide_u64_div_by_7
                        time:   [25.795 us 26.045 us 26.345 us]
</code></pre>

<p>Division by 7 is hard for compilers that do not implement the “rounded down”
approximation described in Robison’s
<a href="https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.512.2627&amp;rep=rep1&amp;type=pdf">N-Bit Unsigned Division Via N-Bit Multiply-Add</a>.
This is the comparative <em>best</em> case for reciprocal, since it always
uses the same code (1.3 ns/division), but most other implementations
switch to a slow path (strength_reduce only implements that slow path,
but with code that’s transparent to LLVM). Even divisions directly
compiled with LLVM isareonly ~20% faster than reciprocal (LLVM does not
implement Robison’s round-down scheme, so it’s a hardcoded codegen for
a more complex sequence than reciprocal’s).</p>

<p>\(10^4\) divisions by 11 (a regular division)</p>

<pre><code>hardware_u64_div_11     time:   [95.199 us 95.733 us 96.213 us]
compiled_u64_div_by_11  time:   [7.0886 us 7.1565 us 7.2309 us]
reciprocal_u64_div_by_11
                        time:   [12.841 us 13.171 us 13.556 us]
strength_reduce_u64_div_by_11
                        time:   [17.026 us 17.318 us 17.692 us]
fast_divide_u64_div_by_11
                        time:   [21.731 us 21.918 us 22.138 us]
</code></pre>

<p>This is a typical result. Again, reciprocal can be trusted to work at
1.3 ns/division.  Regular round-up div-by-mul works fine when dividing
by 11, so code compiled by LLVM only needs a multiplication and a shift,
nearly twice as fast as reciprocal’s generic sequence.  The fast_divide
crate does do better here than when dividing by 7, since it avoids the
slowest path, but is still slower than reciprocal; simplicity helps.</p>

<p>The three microbenchmarks above reward special casing, since we always
divide by the same constant in a loop, and thus always hit the same
code path without ever mispredicting a branch.</p>

<p>What happens when we <a href="https://github.com/pkhuong/reciprocal/blob/main/benches/div_throughput_variable.rs">pick unpredictably from four precomputed divisors</a>,
for divisions by 2, 3, 7, or 11 (one easy, one hard, and two regular divisors)?</p>

<pre><code>hardware_u64_div        time:   [91.592 us 93.211 us 95.125 us]
reciprocal_u64_div      time:   [17.436 us 17.620 us 17.828 us]
strength_reduce_u64_div time:   [40.477 us 41.581 us 42.891 us]
fast_divide_u64_div     time:   [69.069 us 69.562 us 70.100 us]
</code></pre>

<p>The hardware doesn’t care, and reciprocal is only a bit slower (1.8
ns/division instead of 1.3 ns/division) presumably because the relevant
<code>PartialReciprocal</code> struct must now be loaded in each iteration.</p>

<p>The other two branchy implementations seemingly take a hit
proportional to the number of special cases. The <code>strength_reduce</code> hot
path only branches once, to detect divisors that are powers of two;
its runtime goes from 0.29 - 1.8 ns/division to 4.2 ns/division (at
least 2.4 ns slower/division).  The <code>fast_divide</code> hot path switches
between <em>three</em> cases (like libdivide), and goes from 0.28 - 2.2
ns/division to 7.0 ns/division (at least 4.8 ns slower/division).</p>

<p>And that’s why I prefer to start with predictable baseline
implementations: unpredictable code with special cases can easily
perform well on benchmarks, but, early on during development, it’s
hard to tell how the benchmarks may differ from real workloads, and
whether the special cases “overfit” on these differences.</p>

<p>With special cases for classes of divisors, most runtime div-by-mul
implementations make you guess whether you’ll tend to divide by powers
of two, by “regular” divisors, or by “hard” ones in order to estimate
how they will perform.  Worse, they also force you to take into
account how often you’ll switches between the different classes.
Reciprocal does not have that problem: its hot path is the same
regardless of the constant divisor, so it has the same predictable
performance for all divisors<sup id="fnref:partial" role="doc-noteref"><a href="#fn:partial" class="footnote" rel="footnote">2</a></sup>,
and there’s only one code path, so we don’t have to worry about class
switch.</p>

<p>Depending on the workload, it may make sense to divert to faster code
paths, but it’s usually best to start without special cases when it’s
practical to do so…  and I think
<a href="https://crates.io/crates/reciprocal">reciprocal</a> shows that, for
integer division by constants, it is.</p>

<p><hr style="width: 50%" /></p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:why-partial" role="doc-endnote">
      <p>the struct is “partial” because it can’t represent divisions by 1 or <code>u64::MAX</code>. <a href="#fnref:why-partial" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:partial" role="doc-endnote">
      <p>…all divisors except 1 and <code>u64::MAX</code>, which can instead <a href="https://github.com/pkhuong/reciprocal/blob/d591c59044b3a4f662112aae73c3adae9f168ea6/src/lib.rs#L176">use the <code>Reciprocal</code> struct</a>. <a href="#fnref:partial" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/Blog/archives">Blog Archives</a>
    
  </div>
</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Website copyright &copy; 2021 - <a href="mailto:pvk@pvk.ca">Paul Khuong</a> | <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/TheChymera/Koenigspress">Königspress</a></span>
</p>

</footer>
  

<script id="dsq-count-scr" src="//pvk.disqus.com/count.js" async></script>












<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-20468541-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>
