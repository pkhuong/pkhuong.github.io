<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<link href="http://www.pvk.ca/Blog/stylesheet.css" rel="stylesheet" type="text/css" />
 <title>Space-complexity of SSA in practices - Paul Khuong mostly on Lisp</title>
<link rel="alternate" type="application/rss+xml" title="RSS" href="index.rss20" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-20468541-1']);
  _gaq.push(['_trackPageview']);
</script>
</head>
<body>
<div class="content">
    <h1>Paul Khuong mostly on Lisp</h1>
<p />
<small><a href="index.rss20">rss feed</a></small>
<h2>Sat, 05 Nov 2011</h2>
<div class="entry">
  <a id="SSA_in_practices" style="text-decoration: none">&nbsp;</a>
  <div class="entry-body">
    <div class="entry-head">
      <div class="entry-title">
        <h3>Space-complexity of SSA in practices</h3>
      </div>
    </div>
    <div class="entry-text">

<!--l. 11--><p style="text-indent:0em">Converting code to static single assignment style really simplifies analyses in
compilers. The ease with which I can hack things up in LLVM&#8217;s SSA intermediate
representation is impressive, especially when compared to the same task in SBCL&#8217;s
mostly-CFG IR.
</p><!--l. 16--><p style="text-indent:1.5em">   In theory, there&#8217;s an important downside to converting to SSA before analyses:
the conversion can cause a quadratic explosion in size from the source to the IR.
A linear-time pass on an SSA-converted IR is actually quadratic-time (in
the worst case) with respect to the initial input. Obviously, this is an issue
for just-in-time compilation, but also for some lisp and scheme compilers.
SBCL is frequently used to compile very large, programmatically-generated,
functions, and I&#8217;m told that Chez Scheme faces similar challenges. The fact that
both languages have local functions compounds the issue: analysing a single
toplevel function can actually be equivalent to interprocedural analyses in other
languages.
</p><!--l. 28--><p style="text-indent:1.5em">   On the other hand, all the reference texts on SSA construction that I&#8217;ve read
reassure the reader that the output is linear-size in practice... the practice of Fortran,
C, and other curly-brace languages, that is.
</p><!--l. 33--><p style="text-indent:1.5em">   What&#8217;s the practical size blowup like in Scheme or Lisp? I think it&#8217;s much closer
to the theoretical worst case.
</p><!--l. 36--><p style="text-indent:1.5em">   The worst-case expansion for SSA happens when a <em style="font-style:italic">&#981; </em>node is inserted for each
variable at the head of each basic block. A function with <em style="font-style:italic">m </em>variables and <em style="font-style:italic">n </em>basic
blocks (i.e. size <em style="font-style:italic">m </em>+ <em style="font-style:italic">n</em>) is converted into something with an additional <em style="font-style:italic">mn</em>
<em style="font-style:italic">&#981;</em>s.
</p><!--l. 41--><p style="text-indent:1.5em">   Unfortunately, that&#8217;s exactly what tends to happen for code generated by the
macro in Shriram Krishnamurthi&#8217;s <a href="http://www.cs.brown.edu/~sk/Publications/Papers/Published/sk-automata-macros/">Automata via Macros</a>. That&#8217;s a pretty bad sign:
the macro is simple enough that the author used it as a pedagogic example. It
also seems very idiomatic; it&#8217;s certainly very close to how I would solve the
problem.
</p><!--l. 48--><p style="text-indent:1.5em">   In something like C, I would implement that simple state machine with a <code style="font-family:monospace">while</code>
loop and a <code style="font-family:monospace">switch</code>:
                                                                  

                                                                  
</p>
   <pre id="verbatim-1" style="white-space:pre; clear:both; font-family:monospace; text-align:left" align="left">        enum state state = ...; 
        int var1 = ..., var2 = ..., ...; 
        while (1) { 
                switch (state) { 
                case ... 
                } 
        };</pre>
<!--l. 58--><p style="text-indent:0em">
</p><!--l. 60--><p style="text-indent:1.5em">   That loop has a linear-size SSA conversion. Each state has a single successor,
and <em style="font-style:italic">&#981; </em>are only inserted at the head of the <code style="font-family:monospace">while </code>loop. <code style="font-family:monospace">clang </code>and the <code style="font-family:monospace">llvm</code>
toolchain are perfect for this sort of exploration. The tricky thing is that <code style="font-family:monospace">clang</code>&#8217;s
optimisations involve some code duplication, even at <code style="font-family:monospace">-O1</code>. It&#8217;s probably best to
compile to bitcode, at <code style="font-family:monospace">-O0</code>, and then use <code style="font-family:monospace">opt </code>to enable only the passes we need
(<code style="font-family:monospace">mem2reg </code>to convert to SSA and <code style="font-family:monospace">jump-threading </code>to clean up trivial basic
blocks).
</p><!--l. 69--><p style="text-indent:1.5em">   The automaton macro&#8217;s output is equivalent to having a few <code style="font-family:monospace">goto </code>at the end of
each state:
                                                                  

                                                                  
</p>
   <pre id="verbatim-2" style="white-space:pre; clear:both; font-family:monospace; text-align:left" align="left">        { 
        s0: 
                var1++; 
                if (...) goto s1; 
                goto s4; 
        s1: ... 
        }</pre>
<!--l. 79--><p style="text-indent:0em">
</p><!--l. 81--><p style="text-indent:1.5em">   Clearly, it will more easily yield efficient code, and is arguably more transparent
to analyses. However, even very simple states &#8211; only one variable is read or
written, and there are two successors &#8211; like the one shown above can have a
quadratic-size SSA conversion (of course, at least one of the states must
also use the variables to compute a return value, otherwise all that code is
dead).
</p><!--l. 88--><p style="text-indent:1.5em">   It suffices to have <em style="font-style:italic">n </em>basic blocks and <em style="font-style:italic">n </em>variables, with each basic block writing
and reading exactly one variable (and each variable being read and written by
exactly one basic block). If there are two (directed) cycles that go through each of
<em style="font-style:italic">n </em>basic blocks (in different order), the conversion will have <em style="font-style:italic">n &#981; </em>nodes in
each basic block. In fact, I think it suffices for the basic blocks to form a
single strong component, and for each basic block to have more than one
predecessor.
</p><!--l. 97--><p style="text-indent:1.5em">   That condition is not very strong. I don&#8217;t think I would even express logic as a
state machine if the automaton in question did not have a large number of states
with multiple predecessors in a single strong component; without either of those
conditions, normal conditional branches and a couple small loops would probably be
easier to read and write.
</p><!--l. 104--><p style="text-indent:1.5em">   One argument I can see against this example is that idiomatic Scheme would lift
the variables as arguments to each state function. The corresponding SSA IR isn&#8217;t
smaller, though. The main difference is that the size explosion is done by the macro,
at the source level, instead of a later IR construction pass. If anything, it&#8217;s an
argument against manually writing &#8220;pure&#8221; tail-recursive loops in Scheme: generating
a quadratically blown-up intermediate representation is definitely not a task for
human programmers.
</p><!--l. 113--><p style="text-indent:1.5em">   So, it seems that the practice of static single assignment differs between C-style
and lisp-esque languages. I don&#8217;t know whether the difference is large and common
enough to be an issue, however. Simpler analyses may very well compensate for the
size increase. Lambda-lifted IRs are very common in functional language compilers,
and those are even more easily trapped into quadratic code size explosions. For now,
I&#8217;ll try and figure out if we can be clever and adapt a lambda-lifted IR so
that it has the same (or comparable) size increase vulnerabilities as SSA.
</p> 


    </div>
<p>
  posted at: 15:47 | <a href="http://www.pvk.ca/Blog/Implementation" title="path">/Implementation</a> | <a href="http://www.pvk.ca/Blog/Implementation/SSA_in_practices.html">permalink</a>
</p>
  </div>
</div>
<p>
  <a href="http://pyblosxom.bluesock.org/"><img src="http://pyblosxom.bluesock.org/images/pb_pyblosxom.gif" alt="Made with PyBlosxom" /></a>
  <small>Contact me by email: pvk@pvk.ca.</small>
</p>
</div>
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
