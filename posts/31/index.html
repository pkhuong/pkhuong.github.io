
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Paul Khuong: some Lisp</title>
  <meta name="author" content="Paul Khuong">
  <meta name="description" content="Paul Khuong's personal blog. Some Lisp, some optimisation, mathematical or computer.">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://www.pvk.ca/posts/31/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Paul Khuong: some Lisp" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Poller+One&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Germania+One&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fontdiner+Swanky&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Lato&subset=latin-ext&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Cardo&subset=latin-ext&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Sorts+Mill+Goudy&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=EB+Garamond&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Della+Respira&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=UnifrakturMaguntia&subset=all&display=fallback" rel="stylesheet" type="text/css">
<link href='//fonts.googleapis.com/css?family=Arimo|EB+Garamond|PT+Sans+Caption&subset=latin,cyrillic&display=fallback' rel='stylesheet' type='text/css'>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  TeX: {
    Macros: {
     sp: "^",
     sb: "_"
    }
  }});
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<meta name="twitter:dnt" content="on">

</head>

<body >
  <header role="banner"><hgroup>
  <h1><a href="/">Paul Khuong: some Lisp</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/Blog/archives">Archives</a></li>
  <li><a href="/atom.xml" title="subscribe via RSS">RSS</a></li>
</ul>

<br>

      
        <form action="https://google.com/search" method="get">
          <fieldset role="search">
            <input type="hidden" name="q" value="site:https://www.pvk.ca" />
      
      
            <input class="search" type="text" name="q" results="0" placeholder="Search" aria-label="Search"/>
          </fieldset>
        </form>
  
</nav>
  <div id="main">
    <div id="content">
      
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title" style="font-family: "><a href="/Blog/2014/03/30/refactoring-with-lz77-compilation-is-compression/">Refactoring with LZ77: compression is compilation (?)</a></h1>
    
    
      <p class="meta">
        





Mar
  
30th, 
2014




        
         | <a href="/Blog/2014/03/30/refactoring-with-lz77-compilation-is-compression/#disqus_thread"
              data-disqus-identifier="https://www.pvk.ca/Blog/2014/03/30/refactoring-with-lz77-compilation-is-compression/"
	      >Comments</a>
        
        
      </p>
    
  </header>



  <div class="entry-content" style="font-family: ; font-size: "><p><em>This post was written under the influence of coffee ice cream and
espresso.  It’s a magical drink ;)</em></p>

<p><img class="right" src="/images/2014-03-30-refactoring-with-lz77-compilation-is-compression/espresso_ice_cream.jpg" /></p>

<p>I don’t really follow the compression scene, and only pay minimal
attention to machine learning.  Nevertheless, the “Compression is
Learning” slogan feels more and more right to me.  In this post, I’ll
explore another relationship that I find surprising: one between
compression and compilation.</p>

<p>Five years ago, I took Marc Feeley’s compiler class, and he let us
choose our term project.  I settled on generating traces from
recursive algorithms (typical of cache-oblivious algorithms) and
<a href="http://discontinuity.info/~pkhuong/ift6232/">reordering them to get iterative code</a>
that was better suited to the first level of cache.  I came up with a
gnarly CL-accented research-quality prototype, but the result was
surprisingly effective.  Sadly, I never really managed to recover
loops or function calls from the fully inlined trace, so even
medium-size kernels would exhaust the instruction cache.</p>

<p>I believe I now see a practical and scalable solution, thanks to Artur
Jez’s work on
<a href="http://arxiv.org/abs/1403.4445">“A really simple approximation of smallest grammar.”</a>
His work might lead to a function-oriented analogue of trace
compilation.  Trace compilers are notoriously weak on recursion
(recursive function calls don’t map well to loops), so it would be
nifty to have an alternative that identifies functions rather than
loops.</p>

<p>This makes me quip that “(Trace) Compilation is Compression.”  We
can see trace compilers as lazily unpacking traces from the source
program, rewriting them a bit, and recompressing traces in an
executable format.  Admittedly, the analogy is a bit of a stretch for
classical compilers: they are less aggressive in decompressing source
code and directly translate from one compressed representation (a
small source file may describe billions of execution paths) to
another.</p>

<p>Anyway… this is extremely hypothetical and Jez’s work is fun
independently of my weekend speculations.</p>

<h1 id="how-to-fail-with-lz77">How to fail with LZ77</h1>

<p>Once we cast a program trace as a sequence of opcodes (perhaps
without operands, to expose more redundancy), it’s obvious that
reducing code size is “just” compression, and
<a href="http://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ-type algorithms</a>
quickly come to mind: they compress strings by referring to earlier
substrings.</p>

<p>The heart of LZ77 is a loop that streams through the input sequence
and finds the longest common subsequence earlier in the input.  In
practice, the search usually considers a fixed-size window; when I
write LZ77 here, I instead refer to the theoretical approach with an
unbounded search window.  Repeated LCS searches on an unbounded window
sounds slow, but, in sophisticated implementations, the bottleneck is
sorting the input string to generate a suffix array.</p>

<p>I don’t feel like being sophisticated and will implement a
quadratic-time LCS search.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(defun longest-subseq (seq start)
</span><span class="line">  "Find the longest subseq of seq[start...] that begins before start."
</span><span class="line">  (let ((best 1)
</span><span class="line">        (index nil))
</span><span class="line">    (dotimes (i start (values index best))
</span><span class="line">      (let ((length (mismatch seq seq :start1 i :start2 start
</span><span class="line">                                      :test #'equal)))
</span><span class="line">        (assert length)
</span><span class="line">        (decf length i)
</span><span class="line">        (when (&gt; length best)
</span><span class="line">          (setf best length
</span><span class="line">                index i))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Some backreferences clearly look like function calls.</p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (longest-subseq "abab" 0)
</span><span class="line">NIL ; There is no match to the left of abab
</span><span class="line">1   ;                                  ^
</span><span class="line">CL-USER&gt; (longest-subseq "abab" 2)
</span><span class="line">0   ; There is a match for the second ab, starting
</span><span class="line">2   ; at index 0 and spanning 2 characters.</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>It’s a bit surprising at first, but some also correspond to <code>repeat</code> loops.</p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (longest-subseq "abababa" 2)
</span><span class="line">0 ; There is a match for "ababa", starting
</span><span class="line">5 ; at index 0 and spanning 5 characters.</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This last patch is strange because it’s self-referential.  However, if
we decompress character by character, its meaning becomes obvious: we
replicate the substring in <code>[0, 1]</code> to generate exactly 5 characters.
This is basically a loop; we can handle partial copies with, e.g.,
rotation and entering the middle of the loop (like Duff’s device).</p>

<p>Lempel and Ziv’s result tells us that we can look for references
greedily in an unbounded window and obtain asymptotically optimal
(proportional to the string’s entropy) compression.  Again, there are
algorithms to do that in linear time – via radix sort – but I’ll just
bruteforce my way in cubic time.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(defstruct factor start length subseq)
</span><span class="line">
</span><span class="line">(defun factorise (seq)
</span><span class="line">  (let ((index 0)
</span><span class="line">        (length (length seq)))
</span><span class="line">    (loop while (&lt; index length)
</span><span class="line">          collect
</span><span class="line">          (multiple-value-bind (start length)
</span><span class="line">              (longest-subseq seq index)
</span><span class="line">            (prog1
</span><span class="line">                (if (null start)
</span><span class="line">                    (elt seq index)
</span><span class="line">                    (make-factor :start start :length length
</span><span class="line">                                 :subseq (subseq seq start (+ start length))))
</span><span class="line">              (incf index length))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here’s the problem with converting an LZ77 factorisation into calls and
loops: there is no guarantee that patches nest sanely.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (factorise "ababac||bac")
</span><span class="line">(#\a #\b #S(FACTOR :START 0 :LENGTH 3 :SUBSEQ "aba") #\c #\| #\|
</span><span class="line"> #S(FACTOR :START 3 :LENGTH 3 :SUBSEQ "bac"))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This factorisation encodes “ababac||bac” by repeating “ab” two and a
half times, inserting “c||”, and then repeating “bac.”  The issue is
that we wish to convert “ababa” into a loop, but the last patch would
then need to enter that loop in its last iteration.  We could also
have the opposite problem, with a patch that only covers a prefix of
an earlier patch (a few iterations of a loop).  The sketch below shows
how we might even have to deal with both issues in the same factor.</p>

<p><img class="center" src="/images/2014-03-30-refactoring-with-lz77-compilation-is-compression/nasty-factor.jpg" /></p>

<h1 id="jezs-solution">Jez’s solution</h1>

<p><a href="http://arxiv.org/abs/1403.4445">Jez’s paper</a> analyses a method to
recover a CFL with a single member, the string we wish to compress.
The CFL is described by a fully deterministic (it produces exactly one
string) CFG in Chomsky normal form, i.e., a straight-line program.</p>

<p>This “really simple” approach takes a step back from LZ compression
and instead starts with the easiest, greedy, way to generate a
straight-line program from a string: just pair characters as you
encounter them, left-to-right.</p>

<p>For example, on “abab,” this would pair “(ab)(ab)” and then
“((ab)(ab)),” and generate the following grammar:</p>

<pre><code>G -&gt; XX
X -&gt; ab
</code></pre>

<p>We got lucky: the repetition synced up with the greedy pairing.
That’s not always the case; for example, “abcab” becomes “(ab)(ca)b” – which
exposes no redundancy – rather than “(ab)c(ab).”</p>

<p>Jez addresses this issue by using LZ77 factorisation as an oracle to
synchronise pairings.</p>

<p>First, we simplify the algorithm by assuming that there are no factors that
begin exactly one character before their output.  Such factors correspond to
repetitions of that one character (e.g., “aaaa” = “a” x 4) and we can easily 
turn them into repetitions of a pair (e.g., “aa” x 2).</p>

<p>It’s then simply a matter of not pairing when it would prevent the
next character from synchronising with its backreference.  For
example, in “abcab,” we’d skip pairing “ca” so that “ab” could pair
like the first occurrence did.  We also don’t force a pair when the
backreference only includes the first letter, but not the second.
Finally, we opportunistically match consecutive unpaired letters.</p>

<p><img class="center" src="/images/2014-03-30-refactoring-with-lz77-compilation-is-compression/jez.jpg" /></p>

<p>Each such pass creates a new, shorter, string of literals and production rules. 
We iteratively apply the guided pairing loop until we’re left with a single
production rule.</p>

<p>That’s it.  Jez’s paper is mostly concerned with showing that we only
have to run LZ compression once and with proving suboptimality bounds.
The key is that we can convert factors for the input into factors for
the output, and that each pass shrinks the string by a multiplicative
factor.  I’ll simplify things further by recomputing a factorisation
(in cubic time!) from scratch in each pass.</p>

<h1 id="now-the-code">Now, the code</h1>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
</pre></td><td class="code"><pre><code class=""><span class="line">;; specials for shared state (quick-and-dirty REPL style)
</span><span class="line">
</span><span class="line">;; For each character position, whether it's the first or
</span><span class="line">;; second of a pair, or just a singleton (nil)
</span><span class="line">(defvar *state*)
</span><span class="line">;; The sequence to compress.
</span><span class="line">(defvar *sequence*)
</span><span class="line">;; Cursor in the sequence.
</span><span class="line">(defvar *index*)
</span><span class="line">
</span><span class="line">(defmacro with-sequence ((seq) &amp;body body)
</span><span class="line">  (let ((temp (gensym "SEQ")))
</span><span class="line">    `(let* ((,temp ,seq)
</span><span class="line">            (*sequence* ,temp)
</span><span class="line">            (*state* (make-array (length *sequence*)
</span><span class="line">                                 :initial-element nil))
</span><span class="line">            (*index* 0))
</span><span class="line">       ,@body)))
</span><span class="line">
</span><span class="line">;; No pair begins here, but we might still fuse with the previous
</span><span class="line">;; singleton.
</span><span class="line">(defun single ()
</span><span class="line">  (let ((i *index*))
</span><span class="line">    (when (and (plusp i)
</span><span class="line">               (null (aref *state* (1- i))))
</span><span class="line">      (setf (aref *state* (1- i)) 'first
</span><span class="line">            (aref *state* i) 'second)))
</span><span class="line">  (incf *index*))
</span><span class="line">
</span><span class="line">;; Force a pair.
</span><span class="line">(defun pair ()
</span><span class="line">  (let ((i *index*))
</span><span class="line">    ;; we mustn't be at the end of the sequence
</span><span class="line">    (assert (&lt; (1+ i) (length *sequence*)))
</span><span class="line">    (setf (aref *state* i) 'first)
</span><span class="line">    (setf (aref *state* (1+ i)) 'second)
</span><span class="line">    (incf *index* 2)))
</span><span class="line">
</span><span class="line">(defun sync-and-pair ()
</span><span class="line">  (multiple-value-bind (begin length)
</span><span class="line">      (longest-subseq *sequence* *index*)
</span><span class="line">    (cond ((null begin)
</span><span class="line">           ;; No factor; advance and merge greedily.
</span><span class="line">           (single))
</span><span class="line">          ((= begin (1- *index*))
</span><span class="line">           ;; Single-character repetition.
</span><span class="line">           (loop repeat length do (single)))
</span><span class="line">          (t
</span><span class="line">           (let ((end (+ begin length)))
</span><span class="line">             (assert (&lt;= end (length *sequence*)))
</span><span class="line">             (assert (&lt; begin (1- *index*)))
</span><span class="line">             (when (eql 'second (aref *state* begin))
</span><span class="line">               ;; The first character is the second half of a pair;
</span><span class="line">               ;; leave it by itself.
</span><span class="line">               (single)
</span><span class="line">               (incf begin))
</span><span class="line">             ;; Mimic the pairing decisions of the backref.
</span><span class="line">             (loop with expected = (+ *index* (- end begin))
</span><span class="line">                   for i from begin below end
</span><span class="line">                   do (ecase (aref *state* i)
</span><span class="line">                        (second)
</span><span class="line">                        (first (if (= (1+ i) end) ; Last character
</span><span class="line">                                   (single)       ; can't force
</span><span class="line">                                   (pair)))       ; a pair.
</span><span class="line">                        ((nil) (single)))
</span><span class="line">                   finally (assert (= *index* expected))))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>My implementation is exceedingly naïve and runs in cubic time in the
worst case.  With a lot more work, the bottleneck (LZ77 factorisation)
runs at the speed of sort… but constructing a suffix array would only
get in the way of this post.  Let’s just see what pairing the code
generates.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (with-sequence ("abcab")
</span><span class="line">           (loop while (&lt; *index* (length *sequence*))
</span><span class="line">                 do (sync-and-pair)
</span><span class="line">                 finally (return *state*)))
</span><span class="line">#(FIRST SECOND NIL FIRST SECOND)
</span><span class="line">CL-USER&gt; (with-sequence ("abababa")
</span><span class="line">           (loop while (&lt; *index* (length *sequence*))
</span><span class="line">                 do (sync-and-pair)
</span><span class="line">                 finally (return *state*)))
</span><span class="line">#(FIRST SECOND FIRST SECOND FIRST SECOND NIL)
</span><span class="line">CL-USER&gt; (with-sequence ("ababac||bac")
</span><span class="line">           (loop while (&lt; *index* (length *sequence*))
</span><span class="line">                 do (sync-and-pair)
</span><span class="line">                 finally (return *state*)))
</span><span class="line">#(FIRST SECOND FIRST SECOND FIRST SECOND FIRST SECOND NIL FIRST SECOND)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In short, “abcab” becomes “(ab)c(ab)”, “abababa” “(ab)(ab)(ab)a”,
and “ababac||bac” “(ab)(ab)(ac)(||)b(ac)”.</p>

<h1 id="programs-from-pairs">Programs from pairs</h1>

<p>So far, we’ve only made pairing decisions.  The next step is to
translate them into production rules (i.e., functions), and to merge
equivalent rules to actually save space.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(defvar *counter* 0)
</span><span class="line">(defvar *rules* (make-array 0 :adjustable t :fill-pointer 0))
</span><span class="line">
</span><span class="line">(defstruct rule
</span><span class="line">  (id (incf *counter*))
</span><span class="line">  a b)
</span><span class="line">
</span><span class="line">;; Hash-consing naturally merges equivalent rules.
</span><span class="line">(fare-memoization:define-memo-function rule (a b)
</span><span class="line">  (let ((rule (make-rule :a a :b b)))
</span><span class="line">    (vector-push-extend rule *rules*)
</span><span class="line">    rule))
</span><span class="line">
</span><span class="line">(defun reset-rules ()
</span><span class="line">  (setf *counter* 0)
</span><span class="line">  ;; Sorry, this is ugly.
</span><span class="line">  (fare-memoization:unmemoize 'rule)
</span><span class="line">  (fare-memoization:memoize 'rule)
</span><span class="line">  (setf *rules* (make-array 0 :adjustable t :fill-pointer 0)))
</span><span class="line">
</span><span class="line">(defun pair-cfg (sequence state)
</span><span class="line">  (loop with acc = '()
</span><span class="line">        for i upfrom 0
</span><span class="line">        for character across sequence
</span><span class="line">        for choice across state
</span><span class="line">        do (ecase choice
</span><span class="line">             (second)
</span><span class="line">             (first (push (rule character (aref sequence (1+ i)))
</span><span class="line">                          acc))
</span><span class="line">             ((nil) (push character acc)))
</span><span class="line">        finally (return (coerce (nreverse acc) 'simple-vector))))
</span><span class="line">
</span><span class="line">(defun compress-1 (sequence)
</span><span class="line"> (with-sequence (sequence)
</span><span class="line">    (loop with length = (length sequence)
</span><span class="line">          while (&lt; *index* length)
</span><span class="line">          do (sync-and-pair)
</span><span class="line">          finally (return (pair-cfg *sequence* *state*)))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>On the examples above, we find:</p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (reset-rules)
</span><span class="line">#()
</span><span class="line">CL-USER&gt; (compress-1 "abcab")
</span><span class="line">#(#S(RULE :ID 1 :A #\a :B #\b) #\c #S(RULE :ID 1 :A #\a :B #\b))
</span><span class="line">CL-USER&gt; (compress-1 "abababa")
</span><span class="line">#(#S(RULE :ID 1 :A #\a :B #\b) #S(RULE :ID 1 :A #\a :B #\b)
</span><span class="line">  #S(RULE :ID 1 :A #\a :B #\b) #\a)
</span><span class="line">CL-USER&gt; (compress-1 "ababac||bac")
</span><span class="line">#(#S(RULE :ID 1 :A #\a :B #\b) #S(RULE :ID 1 :A #\a :B #\b)
</span><span class="line">  #S(RULE :ID 2 :A #\a :B #\c) #S(RULE :ID 3 :A #\| :B #\|) #\b
</span><span class="line">  #S(RULE :ID 2 :A #\a :B #\c))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We only have to pair production rules further until the sequence
consists of a single rule (or literal).</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(defun refactor (sequence)
</span><span class="line">  (if (&lt;= (length sequence) 1)
</span><span class="line">      sequence
</span><span class="line">      (refactor (compress-1 sequence))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (refactor "ababac||bac")
</span><span class="line">#(#S(RULE
</span><span class="line">     :ID 8
</span><span class="line">     :A #S(RULE
</span><span class="line">           :ID 7
</span><span class="line">           :A #S(RULE
</span><span class="line">                 :ID 4
</span><span class="line">                 :A #S(RULE :ID 1 :A #\a :B #\b)
</span><span class="line">                 :B #S(RULE :ID 1 :A #\a :B #\b))
</span><span class="line">           :B #S(RULE
</span><span class="line">                 :ID 5
</span><span class="line">                 :A #S(RULE :ID 2 :A #\a :B #\c)
</span><span class="line">                 :B #S(RULE :ID 3 :A #\| :B #\|)))
</span><span class="line">     :B #S(RULE :ID 6 :A #\b :B #S(RULE :ID 2 :A #\a :B #\c))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The “call graph” below shows there’s a lot of sharing for such a short string.</p>

<p><img class="center" src="/images/2014-03-30-refactoring-with-lz77-compilation-is-compression/call_graph.png" /></p>

<h1 id="enough-with-the-strings">Enough with the strings</h1>

<p>I started by writing about compiling program traces, but so far I’ve only been
working with strings of characters.  Let’s pretend the following PostScript file
was written by someone who’s never heard of functions or loops.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
</pre></td><td class="code"><pre><code class=""><span class="line">%!PS
</span><span class="line">270 315 translate
</span><span class="line">1.5 setlinewidth
</span><span class="line">
</span><span class="line">gsave
</span><span class="line">newpath
</span><span class="line">  0 36 moveto
</span><span class="line"> 72 0  rlineto
</span><span class="line">  0 72 rlineto
</span><span class="line">-72 0  rlineto
</span><span class="line">closepath
</span><span class="line">stroke
</span><span class="line">grestore
</span><span class="line">
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">
</span><span class="line">showpage</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Phew, programming <em>is</em> hard!  That’s a lot of copy-paste to produce a
simple pattern.</p>

<p><img class="center" src="/images/2014-03-30-refactoring-with-lz77-compilation-is-compression/squares.png" /></p>

<p>Let’s see what our (simplified) implementation of Jez’s algorithm can do.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (reset-rules)
</span><span class="line">#()
</span><span class="line">;; READ, the poor man's tokenizer.
</span><span class="line">CL-USER&gt; (refactor #(
</span><span class="line">270 315 translate
</span><span class="line">1.5 setlinewidth
</span><span class="line">
</span><span class="line">gsave
</span><span class="line">newpath
</span><span class="line">  0 36 moveto
</span><span class="line"> 72 0  rlineto
</span><span class="line">  0 72 rlineto
</span><span class="line">-72 0  rlineto
</span><span class="line">closepath
</span><span class="line">stroke
</span><span class="line">grestore
</span><span class="line">
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">45 rotate gsave newpath 0 36 moveto 72 0 rlineto 0 72 rlineto -72 0 rlineto closepath stroke grestore
</span><span class="line">
</span><span class="line">showpage
</span><span class="line">))
</span><span class="line">#(#S(RULE
</span><span class="line">     :ID 35
</span><span class="line">   ...))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>35 functions that each contain two literals or function calls. Not bad (:
It’s an actual <a href="http://c2.com/cgi/wiki?SimpleMatterOfProgramming">SMOP</a>
to convert this grammar into a PostScript program.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(defun emit-one-rule (stream rule)
</span><span class="line">  (flet ((emit-subrule (x)
</span><span class="line">           (if (rule-p x)
</span><span class="line">               (format nil "R~A" (rule-id x))
</span><span class="line">               (format nil "~(~a~)" x))))
</span><span class="line">    (format stream "/R~A { ~A ~A } def~%"
</span><span class="line">            (rule-id rule)
</span><span class="line">            (emit-subrule (rule-a rule))
</span><span class="line">            (emit-subrule (rule-b rule)))))
</span><span class="line">
</span><span class="line">(defun emit-rules (stream rules)
</span><span class="line">  (map nil (lambda (rule)
</span><span class="line">             (emit-one-rule stream rule))
</span><span class="line">       rules)
</span><span class="line">  (format stream "R~A~%" (rule-id (elt rules (1- (length rules))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CL-USER&gt; (emit-rules *standard-output* *rules*)
</span><span class="line">/R1 { 270 315 } def
</span><span class="line">/R2 { translate 1.5 } def
</span><span class="line">/R3 { setlinewidth gsave } def
</span><span class="line">/R4 { newpath 0 } def
</span><span class="line">/R5 { 36 moveto } def
</span><span class="line">/R6 { 72 0 } def
</span><span class="line">/R7 { rlineto 0 } def
</span><span class="line">/R8 { 72 rlineto } def
</span><span class="line">/R9 { -72 0 } def
</span><span class="line">/R10 { rlineto closepath } def
</span><span class="line">/R11 { stroke grestore } def
</span><span class="line">/R12 { 45 rotate } def
</span><span class="line">/R13 { R1 R2 } def
</span><span class="line">/R14 { R3 R4 } def
</span><span class="line">/R15 { R5 R6 } def
</span><span class="line">/R16 { R7 R8 } def
</span><span class="line">/R17 { R9 R10 } def
</span><span class="line">/R18 { R11 R12 } def
</span><span class="line">/R19 { gsave R4 } def
</span><span class="line">/R20 { R11 showpage } def
</span><span class="line">/R21 { R13 R14 } def
</span><span class="line">/R22 { R15 R16 } def
</span><span class="line">/R23 { R17 R18 } def
</span><span class="line">/R24 { R17 R20 } def
</span><span class="line">/R25 { R21 R22 } def
</span><span class="line">/R26 { R23 R19 } def
</span><span class="line">/R27 { R22 R24 } def
</span><span class="line">/R28 { R25 R26 } def
</span><span class="line">/R29 { R22 R26 } def
</span><span class="line">/R30 { R28 R29 } def
</span><span class="line">/R31 { R29 R29 } def
</span><span class="line">/R32 { R29 R27 } def
</span><span class="line">/R33 { R30 R31 } def
</span><span class="line">/R34 { R31 R32 } def
</span><span class="line">/R35 { R33 R34 } def
</span><span class="line">R35</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This second PostScript program comprises 211 tokens, rather than the
original’s 156, but 105 of those are “{ } def” noise to define
functions.  Arguably, the number of meaningful tokens was reduced from
156 to slightly more than 100.  Crucially, the output remains the
same.</p>

<p><img class="center" src="/images/2014-03-30-refactoring-with-lz77-compilation-is-compression/squares2.png" /></p>

<p>Stack programs seem particularly well suited to this rewriting
approach: explicit operands (e.g., registers) introduce trivial
discrepancies.  In a VM, I would consider “compressing” the opcode
stream separately from the operands.  Compiling only the former to
native code would already reduce interpretative overhead, and
extracting function calls from the instruction stream should avoid
catastrophic size explosions.</p>

<p>There are several obvious deficiencies in the direct LZ77-guided
pairing.  Just breaking Chomsky normalisation to inline single-use
function would already help.  It might also make sense to special-case
repetitions as <code>repeat n</code> loops, instead of hiding that in
\(\log n\) levels of recursion.  In a real program, it would also be
useful to inline the bottom-most rules so as not to drown in control
flow.  The thing is, destroying structure in the name of performance
is well understood compiler tech; recovering it <em>efficiently</em> was the
hard part.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/32">&larr; Older</a>
    
    <a href="/Blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/30">Newer &rarr;</a>
    
  </div>
</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Website copyright &copy; 2020 - <a href="mailto:pvk@pvk.ca">Paul Khuong</a> | <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/TheChymera/Koenigspress">Königspress</a></span>
</p>

</footer>
  

<script id="dsq-count-scr" src="//pvk.disqus.com/count.js" async></script>












<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-20468541-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>
