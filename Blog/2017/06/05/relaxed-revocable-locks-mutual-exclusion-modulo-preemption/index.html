
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Relaxed revocable locks: mutual exclusion modulo preemption - Paul Khuong: some Lisp</title>
  <meta name="author" content="Paul Khuong">
  <meta name="description" content="Paul Khuong's personal blog. Some Lisp, some optimisation, mathematical or computer.">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://www.pvk.ca/Blog/2017/06/05/relaxed-revocable-locks-mutual-exclusion-modulo-preemption/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Paul Khuong: some Lisp" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Poller+One&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Germania+One&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Fontdiner+Swanky&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Lato&subset=latin-ext&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Cardo&subset=latin-ext&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Sorts+Mill+Goudy&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=EB+Garamond&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=Della+Respira&display=fallback" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=UnifrakturMaguntia&subset=all&display=fallback" rel="stylesheet" type="text/css">
<link href='//fonts.googleapis.com/css?family=Arimo|EB+Garamond|PT+Sans+Caption&subset=latin,cyrillic&display=fallback' rel='stylesheet' type='text/css'>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  TeX: {
    Macros: {
     sp: "^",
     sb: "_"
    }
  }});
</script>
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<meta name="twitter:dnt" content="on">

</head>

<body >
  <header role="banner"><hgroup>
  <h1><a href="/">Paul Khuong: some Lisp</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/Blog/archives">Archives</a></li>
  <li><a href="/atom.xml" title="subscribe via RSS">RSS</a></li>
</ul>

<br>

      
        <form action="https://google.com/search" method="get">
          <fieldset role="search">
            <input type="hidden" name="q" value="site:https://www.pvk.ca" />
      
      
            <input class="search" type="text" name="q" results="0" placeholder="Search" aria-label="Search"/>
          </fieldset>
        </form>
  
</nav>
  <div id="main">
    <div id="content">
      
      <div>
<article class="hentry" role="article">
  
  <header>
    
      
        <h1 class="entry-title" style="font-family: ">Relaxed revocable locks: mutual exclusion modulo preemption</h1>
      
    
    
      <p class="meta">
        





June
  
5th, 
2017




        
         | <a href="#disqus_thread"
              data-disqus-identifier="https://www.pvk.ca/Blog/2017/06/05/relaxed-revocable-locks-mutual-exclusion-modulo-preemption/"
	      >Comments</a>
        
        
      </p>
    
  </header>



<div class="entry-content" style="font-family: ; font-size: "><p><em>Update: there’s a way to detect “running” status even across cores.
 It’s not pretty.  Search for <code>/proc/sched_debug</code>.</em></p>

<p>The hard part about locking tends not to be the locking itself, but
preemption.  For example, if you structure a memory allocator
like jemalloc, you want as few arenas as possible; one per CPU would
be ideal, while one per thread would affect fragmentation and make
some operations scale linearly with the number of threads.  However,
you don’t want to get stuck when a thread is preempted while it owns
an arena.  The usual fix is two-pronged:</p>

<ol>
  <li>have a few arenas per CPU (e.g., jemalloc defaults to 4x the
number of CPUs);</li>
  <li>hold exclusive ownership for short critical sections.</li>
</ol>

<p>The first tweak isn’t that bad; scaling the number of arenas, stats
regions, etc. with the number of CPUs is better than scaling with the
number of threads.  The second one really hurts performance: <em>each</em>
allocation must acquire a lock with an interlocked write.  Even if the
arena is (mostly) CPU-local, the atomic wrecks your pipeline.</p>

<p>It would be nice to have locks that a thread can acquire once per
scheduling quantum, and benefit from ownership until the thread is
scheduled out.  We could then have a few arenas per CPU (if only to
handle migration), but amortise lock acquisition over the timeslice.</p>

<p>That’s not a new idea.  <a href="http://dl.acm.org/citation.cfm?id=512451">Dice and Garthwaite</a> described this
exact application in 2002
<a href="https://pdfs.semanticscholar.org/5c9e/780fb6e6890d853fb5e44d1b7ce51a68a900.pdf">(PDF)</a>
and refer to older work for uniprocessors.  However, I think the best
exposition of the idea is Harris and Fraser’s
<a href="http://dl.acm.org/citation.cfm?id=1065954">Revocable locks for non-blocking programming</a>,
published in 2005 <a href="https://pdfs.semanticscholar.org/21eb/486b4ef3b059d782ea1976b4ea5985e417df.pdf">(PDF)</a>.  Harris and Fraser want revocable locks for
non-blocking multiwriter code; our problem is easier, but only marginally so.
Although the history of revocable locks is pretty Solaris-centric, Linux
is catching up.   Google, Facebook, and EfficiOS (LTTng) have been pushing for
<a href="https://lwn.net/Articles/697979/">restartable sequences</a>, which is essentially
OS support for sections that are revoked on context switches.  Facebook even
has a pure userspace implementation with
<a href="https://github.com/facebookexperimental/Rseq">Rseq</a>; they report good
results for jemalloc.</p>

<p>Facebook’s Rseq implements almost exactly what I described above, for
the exact same reason (speeding up a memory allocator or replacing
miscellaneous per-thread structs with ~per-CPU data).  However,
they’re trying to port a kernel idiom directly to userspace:
restartable sequences implement strict per-CPU data.  With kernel
supports, that makes sense.  Without such support though, strict
per-CPU data incurs a lot of extra complexity when a thread migrates
to a new CPU: Rseq needs an asymmetric fence to ensure that the
evicted thread observes its eviction and publishes any write it
performed before being evicted.</p>

<p>I’m not sure that’s the best fit for userspace.  We can avoid a lot of
complexity by instead dynamically allocating a few arenas (exclusive
data) per CPU and assuming only a few threads at a time will be
migrated <em>while owning arenas</em>.</p>

<p>Here’s the relaxed revocable locks interface I propose:</p>

<ol>
  <li>Each thread has a thread state struct.  That state struct has:
    <ul>
      <li>a generation counter;</li>
      <li>a canceled counter (generation - 1 or equal to generation);</li>
      <li>a signaled counter (generation - 1 or equal to generation);</li>
      <li>an acknowledged cancel counter (generation - 1 or equal to generation);</li>
      <li>an “in critical section” flag (pointer to a revocable lock).</li>
    </ul>
  </li>
  <li>
    <p>Locks are owned by a pair of thread state struct and generation
counter (ideally packed in one word, but two words are doable).
Threads acquire locks with normal compare-and-swap, but may bulk
revoke every lock they own by advancing their generation counter.</p>
  </li>
  <li>
    <p>Threads may execute any number of conditional stores per lock
acquisition.  Lock acquisition returns an ownership descriptor
(pair of thread state struct and generation counter), and
<code>rlock_store_64(descriptor, lock, dst, value)</code> stores <code>value</code> in
<code>dst</code> if the descriptor still owns the lock and the ownership has
not been cancelled.</p>
  </li>
  <li>Threads do not have to release lock ownership to let others make
progress: any thread may attempt to cancel another thread’s
ownership of a lock.  After <code>rlock_owner_cancel(descriptor, lock)</code>
returns successfully, the victim will not execute a conditional
store under the notion that it still owns <code>lock</code> with <code>descriptor</code>.</li>
</ol>

<p>The only difference from Rseq is that <code>rlock_owner_cancel</code> may fail.
In practice, it will only fail if a thread on CPU A attempts to cancel
ownership for a thread that’s currently running on another CPU B.
That could happen after migration, but also when an administrative
task iterates through every (pseudo-)per-CPU struct without changing
its CPU mask.  Being able to iterate through all available
pseudo-per-CPU data without migrating to the CPU is big win for slow
paths; another advantage of not assuming strict per-CPU affinity.</p>

<p>Rather than failing on migration, Rseq issues an asymmetric fence to
ensure both its writes and the victim’s writes are visible.  At best,
that’s implemented with inter-processor interrupts (IPIs) that scale
linearly with the number of CPUs… for a point-to-point signal.  I
oversubscribed a server with 2-4x more threads than CPUs, and thread
migrations happened at a constant frequency per CPU.  Incurring
<code>O(#CPU)</code> IPIs for every migration makes the <em>per-CPU</em> overhead of
Rseq linear with the number of CPUs (cores) in the system.  I’m also
wary of the high rate of code self/cross -modification in Rseq:
<code>mprotect</code> incurs IPIs when downgrading permissions, so Rseq must
leave some code page with writes enabled.  These downsides (potential
for IPI storm and lack of W\^X) aren’t unique to Rseq.  I think
they’re inherent to emulating unpreempted per-CPU data in userspace
without explicit OS support.</p>

<p>When <code>rlock_owner_cancel</code> fails, I expect callers to iterate down the
<em>list</em> of pseudo-per-CPU structs associated with the CPU and eventually
append a new struct to that list.  In theory, we could end up with as
many structs in that list as the peak number of thread on that CPU; in
practice, it should be a small constant since <code>rlock_owner_cancel</code>
only fails after thread migration.</p>

<h2 id="code-for-rlock-linuxx86-64-only">Code for Rlock (Linux/x86-64 only)</h2>

<p>I <a href="https://gist.github.com/pkhuong/a622e031e92f7fdfb1df1b49a7627d54">dumped my code as a gist</a>, but it is definitely hard to follow, so I’ll try to
explain it here.</p>

<p>Bitpacked ownership records must include the address of the owner
struct and a sequence counter.  Ideally, we’d preallocate some address
space and only need 20-30 bits to encode the address.  For now, I’m
sticking to 64 byte aligned allocations and rely on x86-64’s 48 bits
of address space.  With 64 bit owner/sequence records, an <code>rlock</code>
is a 64 bit spinlock.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>"rlock.c" </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="k">typedef</span> <span class="k">union</span> <span class="n">rlock_owner_seq</span> <span class="p">{</span>
</span><span class="line">        <span class="kt">uint64_t</span> <span class="n">bits</span><span class="p">;</span>
</span><span class="line">        <span class="k">struct</span> <span class="p">{</span>
</span><span class="line">                <span class="kt">uint64_t</span> <span class="nl">sequence</span><span class="p">:</span><span class="mi">22</span><span class="p">;</span>
</span><span class="line">                <span class="kt">uint64_t</span> <span class="nl">address</span><span class="p">:</span><span class="mi">42</span><span class="p">;</span>
</span><span class="line">        <span class="p">};</span>
</span><span class="line"><span class="p">}</span> <span class="n">rlock_owner_seq_t</span><span class="p">;</span>
</span><span class="line">
</span><span class="line"><span class="k">struct</span> <span class="n">rlock</span> <span class="p">{</span>
</span><span class="line">        <span class="n">rlock_owner_seq_t</span> <span class="n">owner</span><span class="p">;</span>
</span><span class="line"><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In the easy case, acquiring an <code>rlock</code> means:</p>

<ol>
  <li>reading the <code>owner</code> field (with a 64 bit load);</li>
  <li>confirming that the owner has advanced its sequence;</li>
  <li>CASing in our own <code>rlock_owner_seq_t</code>.</li>
</ol>

<p>But first, we must make canonicalise our own <code>owner</code> struct.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>"rlock.c" </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="k">struct</span> <span class="n">rlock_owner</span> <span class="p">{</span>
</span><span class="line">        <span class="cm">/* SPMC. */</span>
</span><span class="line">        <span class="n">rlock_owner_seq_t</span> <span class="n">seq</span><span class="p">;</span>
</span><span class="line">        <span class="cm">/* MPMC: Asked to cancel up to here (inclusively). */</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">cancel_sequence</span><span class="p">;</span>
</span><span class="line">        <span class="cm">/* MPMC: Signaled to cancel up to here (inclusively). */</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">signal_sequence</span><span class="p">;</span>
</span><span class="line">        <span class="cm">/* SPMC: Acked cancel ask up to here (inclusively). */</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">acked_sequence</span><span class="p">;</span>
</span><span class="line">        <span class="cm">/* Private: forcibly release lock after too many ops. */</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">op_count</span><span class="p">;</span>
</span><span class="line">        <span class="cm">/* SPMC */</span>
</span><span class="line">        <span class="kt">pid_t</span> <span class="n">tid</span><span class="p">;</span>
</span><span class="line">        <span class="cm">/* SPMC; &quot;in critical section&quot; flag. */</span>
</span><span class="line">        <span class="k">struct</span> <span class="n">rlock</span> <span class="o">*</span><span class="n">critical_section</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">__aligned__</span><span class="p">(</span><span class="mi">64</span><span class="p">)));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Rlock lazily allocates an <code>rlock_owner</code> per thread and stores it in
TLS; we can’t free that memory without some safe memory reclamation
scheme (and I’d like to use Rlock to implement SMR), but it is
possible to use a type-stable freelist.</p>

<p>Regardless of the allocation/reuse strategy, canonicalising an rlock
means making sure we observe any cancellation request.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>"rlock.c" </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span>
</span><span class="line"><span class="nf">update_self</span><span class="p">(</span><span class="k">struct</span> <span class="n">rlock_owner</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">        <span class="n">rlock_owner_seq_t</span> <span class="n">snapshot</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span> <span class="p">};</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">cancel_sequence</span> <span class="o">=</span> <span class="n">ck_pr_load_32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cancel_sequence</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* We&#39;ve been asked to cancel if cancel_sequence == seq.sequence. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">LIKELY</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">sequence</span> <span class="o">!=</span> <span class="n">cancel_sequence</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="n">ck_pr_fas_32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cancel_sequence</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
</span><span class="line">        <span class="n">ck_pr_fas_32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">signal_sequence</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
</span><span class="line">        <span class="n">ck_pr_fas_32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">acked_sequence</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">sequence</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">        <span class="n">snapshot</span><span class="p">.</span><span class="n">sequence</span><span class="o">++</span><span class="p">;</span>
</span><span class="line">        <span class="n">ck_pr_fas_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rlock_owner</span> <span class="o">*</span>
</span><span class="line"><span class="nf">get_self</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">        <span class="k">struct</span> <span class="n">rlock_owner</span> <span class="o">*</span><span class="n">self</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">self</span> <span class="o">=</span> <span class="n">rlock_self</span><span class="p">;</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">self</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="n">self</span> <span class="o">=</span> <span class="n">allocate_self</span><span class="p">();</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="n">update_self</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class="line">        <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>To acquire a lock we observe the current owner, attempt to cancel its
ownership, and (if we did cancel ownership) CAS in our own
owner/sequence descriptor.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>"rlock.c" </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="n">rlock_owner_seq_t</span>
</span><span class="line"><span class="nf">rlock_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">rlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">        <span class="k">struct</span> <span class="n">rlock_owner</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">get_self</span><span class="p">();</span>
</span><span class="line">        <span class="n">rlock_owner_seq_t</span> <span class="n">seq</span><span class="p">,</span> <span class="n">snapshot</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* Load the current owner. */</span>
</span><span class="line">        <span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">ck_pr_load_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
</span><span class="line">        <span class="cm">/* Easy case: we already own the lock. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span> <span class="o">==</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">return</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span><span class="line">                <span class="n">seq</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">                <span class="cm">/* Make sure the current owner isn&#39;t anymore. */</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rlock_owner_cancel</span><span class="p">(</span><span class="n">snapshot</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                        <span class="cm">/* Couldn&#39;t; return 0. */</span>
</span><span class="line">                        <span class="n">seq</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">                        <span class="k">return</span> <span class="n">seq</span><span class="p">;</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">
</span><span class="line">                <span class="cm">/* Replace the old owner with ourself. */</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">ck_pr_cas_64_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span>
</span><span class="line">                    <span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="n">seq</span><span class="p">.</span><span class="n">bits</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                        <span class="cm">/* Success! */</span>
</span><span class="line">                        <span class="k">break</span><span class="p">;</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">
</span><span class="line">                <span class="cm">/* CAS failed.  snapshot.bits has the new owner. */</span>
</span><span class="line">                <span class="cm">/* Eagerly observe any cancellation. */</span>
</span><span class="line">                <span class="n">update_self</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class="line">                <span class="cm">/* CAS failed. Spin a bit. */</span>
</span><span class="line">                <span class="n">ck_pr_stall</span><span class="p">();</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">return</span> <span class="n">seq</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Most of the trickiness hides in <code>rlock_owner_cancel</code>.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>"rlock.c" </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
<span class="line-number">70</span>
<span class="line-number">71</span>
<span class="line-number">72</span>
<span class="line-number">73</span>
<span class="line-number">74</span>
<span class="line-number">75</span>
<span class="line-number">76</span>
<span class="line-number">77</span>
<span class="line-number">78</span>
<span class="line-number">79</span>
<span class="line-number">80</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="kt">bool</span>
</span><span class="line"><span class="nf">rlock_owner_cancel</span><span class="p">(</span><span class="k">union</span> <span class="n">rlock_owner_seq</span> <span class="n">owner</span><span class="p">,</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">rlock</span> <span class="o">*</span><span class="n">evict</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">        <span class="k">struct</span> <span class="n">rlock_owner</span> <span class="o">*</span><span class="n">victim</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">owner</span><span class="p">.</span><span class="n">address</span> <span class="o">*</span> <span class="mi">64</span><span class="p">);</span>
</span><span class="line">        <span class="n">rlock_owner_seq_t</span> <span class="n">snapshot</span><span class="p">;</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">acked</span><span class="p">;</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">owner</span><span class="p">.</span><span class="n">sequence</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">assert</span><span class="p">(</span><span class="n">evict</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">        <span class="cm">/* Easy case: no owner. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">victim</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">ck_pr_load_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span> <span class="o">!=</span> <span class="n">owner</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="cm">/* The victim has already moved on to a new sequence value. */</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="n">acked</span> <span class="o">=</span> <span class="n">ck_pr_load_32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">acked_sequence</span><span class="p">);</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">mod_lte</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">acked</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="cm">/* We already have acked cancellation &gt;= sequence. */</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* Advance the victim&#39;s cancel counter to sequence. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ensure_cancel_sequence</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">sequence</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="cm">/* Already advanced; nothing to do! */</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">victim_running</span><span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="cm">/* The victim isn&#39;t obviously scheduled out;</span>
</span><span class="line">
</span><span class="line"><span class="cm">                /* See if we must ensure visibility of our cancel. */</span>
</span><span class="line">                <span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">ck_pr_load_64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span><span class="p">);</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span> <span class="o">==</span> <span class="n">owner</span><span class="p">.</span><span class="n">bits</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                        <span class="n">ensure_signal_sequence</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">
</span><span class="line">                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">ck_pr_load_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">critical_section</span><span class="p">)</span> <span class="o">!=</span> <span class="n">evict</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="cm">/*</span>
</span><span class="line"><span class="cm">                 * Easy case: victim isn&#39;t in a critical section with</span>
</span><span class="line"><span class="cm">                 * our lock.  The victim has either been scheduled out</span>
</span><span class="line"><span class="cm">                 * since we called `ensure_cancel_sequence`, our went</span>
</span><span class="line"><span class="cm">                 * through a context switch at least once.  In either</span>
</span><span class="line"><span class="cm">                 * case, it has already observed the cancellation or</span>
</span><span class="line"><span class="cm">                 * will before the next critical section.</span>
</span><span class="line"><span class="cm">                 */</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/*</span>
</span><span class="line"><span class="cm">         * The victim might be in the middle of a critical section.</span>
</span><span class="line"><span class="cm">         * Send a signal that&#39;ll skip the critical section if</span>
</span><span class="line"><span class="cm">         * necessary.</span>
</span><span class="line"><span class="cm">         */</span>
</span><span class="line">        <span class="n">ensure_signal_sequence</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>
</span><span class="line">        <span class="cm">/*</span>
</span><span class="line"><span class="cm">         * If the victim is definitely not running, it either has</span>
</span><span class="line"><span class="cm">         * already executed the signal handler or will before resuming</span>
</span><span class="line"><span class="cm">         * normal execution.  If the victim might be running,</span>
</span><span class="line"><span class="cm">         * we can only hope we got lucky.</span>
</span><span class="line"><span class="cm">         */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim_running</span><span class="p">(</span><span class="n">victim</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/*</span>
</span><span class="line"><span class="cm">         * We know the vitim was scheduled out before we signaled for</span>
</span><span class="line"><span class="cm">         * cancellation.  We can see if the victim has released our</span>
</span><span class="line"><span class="cm">         * critical section at least once since then.</span>
</span><span class="line"><span class="cm">         */</span>
</span><span class="line">        <span class="k">return</span> <span class="p">(</span><span class="n">ck_pr_load_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">critical_section</span><span class="p">)</span> <span class="o">!=</span> <span class="n">evict</span><span class="p">);</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>The fancy stuff begins around <code>ensure_cancel_sequence(victim, sequence);</code>.
Our code maintains the invariant that the MPMC sequences
(<code>cancel_sequence</code>, <code>signal_sequence</code>) are either the SPMC <code>sequence - 1</code>
 (normal state), or exactly the SPMC sequence (cancellation
request).</p>

<p><code>ensure_cancel_sequence</code> CASes the <code>cancel_sequence</code> field from its
expected value of <code>owner.sequence - 1</code> to <code>owner.sequence</code>.  If
the actual value is neither of them, the owner has already
advanced to a new sequence value, and we’re done.</p>

<p>Otherwise, we have to hope the victim isn’t running.</p>

<p>Now comes the really tricky stuff.  Our CAS is immediately visible
globally.  The issue is that the victim might already be in the middle
of a critical section.  When writers executes a critical sections, they:</p>

<ol>
  <li>Set the critical section flag (with a normal write);</li>
  <li>Check that the lock hasn’t been revoked;</li>
  <li>Perform the write;</li>
  <li>Clear the critical section flag.</li>
</ol>

<p>It’s really hard to guarantee that the write in step 1 is visible
(without killing performance in the common case), and if it is, that
the victim isn’t about to execute step 3.</p>

<p>We get that guarantee by determining that the victim hasn’t been
continuously executing since the time we attempted to CAS the
<code>cancel_sequence</code> forward.  That’s (hopefully) enough of a barrier to
order the CAS, step 1, and our read of the critical section flag.</p>

<p>That’s not information that Linux exposes directly.  However, we can
borrow a trick from <code>Rseq</code> and read <code>/proc/self/task/[tid]/stat</code>.  The
contents of that file include whether the task is (R)unnable (or
(S)leeping, waiting for (D)isk, etc.), and the CPU on which the task
last executed.</p>

<p>If the task isn’t runnable, it definitely hasn’t been running
continuously since the CAS.  If the task is runnable but last ran on
the CPU the current thread is itself running on (and the current
thread wasn’t migrated in the middle of reading the stat file), it’s
not running now.</p>

<p>If the task is runnable on another CPU, we can try to look at
<code>/proc/sched_debug</code>: each CPU has a <code>.curr-&gt;pid</code> line that tells us
the PID of the task that’s currently running (0 for none).  That file
has a lot of extra information so reading it is <em>really</em> slow, but we
only need to do that after migrations.</p>

<p>Finally, the victim might really be running.  Other proposals would
fire an IPI; we instead ask the caller to allocate a few more
pseudo-per-CPU structs.</p>

<p>Assuming we did get a barrier out of the scheduler, we hopefully
observe that the victim’s critical section flag is clear.  If that
happens, we had:</p>

<ol>
  <li>CAS the cancellation sequence;</li>
  <li>Barrier <em>in the victim</em> from being scheduled out;</li>
  <li>Critical section flag was empty after the CAS.</li>
</ol>

<p>This guarantees that the victim hasn’t been in the same critical
section since the CAS in step 1.  Either it’s not in a critical
section, or if it is, it’s a fresh one that will observe the CAS.
It’s safe to assume the victim has been successfully evicted.</p>

<p>The less happy path happens when we observe that the victim’s critical
section flag is set.  We must assume that it was scheduled out in
the middle of a critical section.  We’ll send a (POSIX) signal to the
victim: the handler will skip over the critical section if the victim
is still in one.  Once that signal is sent, we know that the first
thing Linux will do is execute the handler when the victim resumes
execution.  If the victim is still not running after <code>tgkill</code>
returned, we’re good to go: if the victim is still in the critical
section, the handler will fire when it resumes execution.</p>

<p>Otherwise, the victim might have been scheduled in between the CAS and
the signal; we still have the implicit barrier given by the context
switch between CAS and signal, but we can’t rely on signal execution.
We can only hope to observe that the victim has noticed the
cancellation request and advanced its sequence, or that it cleared its
critical section flag.</p>

<p>The rest is straightforward.  The <code>rlock_store_64</code> must observe any
cancellation, ensure that it still holds the lock, and enter the
critical section:</p>

<ol>
  <li>set the critical section flag (overwrite with the lock’s address);</li>
  <li>check again that we still hold the lock and have not been asked to cancel;</li>
  <li>flip the result flag to “success”;</li>
  <li>store.</li>
</ol>

<p>Once it leaves the critical section, <code>rlock_store_64</code> clears the
critical section flags, looks for any cancellation request, and
returns success/failure.  The critical section is in inline assembly
for the signal handler: executing the store in step 4 implicitly
marks the end of the critical section.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>"rlock.c" </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
<span class="line-number">46</span>
<span class="line-number">47</span>
<span class="line-number">48</span>
<span class="line-number">49</span>
<span class="line-number">50</span>
<span class="line-number">51</span>
<span class="line-number">52</span>
<span class="line-number">53</span>
<span class="line-number">54</span>
<span class="line-number">55</span>
<span class="line-number">56</span>
<span class="line-number">57</span>
<span class="line-number">58</span>
<span class="line-number">59</span>
<span class="line-number">60</span>
<span class="line-number">61</span>
<span class="line-number">62</span>
<span class="line-number">63</span>
<span class="line-number">64</span>
<span class="line-number">65</span>
<span class="line-number">66</span>
<span class="line-number">67</span>
<span class="line-number">68</span>
<span class="line-number">69</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="kt">bool</span>
</span><span class="line"><span class="nf">rlock_store_64</span><span class="p">(</span><span class="n">rlock_owner_seq_t</span> <span class="n">snapshot</span><span class="p">,</span>
</span><span class="line">    <span class="k">struct</span> <span class="n">rlock</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">        <span class="k">struct</span> <span class="n">rlock_owner</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">snapshot</span><span class="p">.</span><span class="n">address</span> <span class="o">*</span> <span class="mi">64</span><span class="p">);</span>
</span><span class="line">        <span class="n">rlock_owner_seq_t</span> <span class="n">seq</span><span class="p">;</span>
</span><span class="line">        <span class="kt">uint32_t</span> <span class="n">op_count</span><span class="p">;</span>
</span><span class="line">        <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">seq</span><span class="p">.</span><span class="n">bits</span> <span class="o">=</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span><span class="p">;</span>
</span><span class="line">        <span class="n">op_count</span> <span class="o">=</span> <span class="o">++</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">op_count</span><span class="p">;</span>
</span><span class="line">        <span class="cm">/* We cancelled this lock. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">seq</span><span class="p">.</span><span class="n">bits</span> <span class="o">!=</span> <span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* The handler will reset RAX to 1 on skip. */</span>
</span><span class="line">        <span class="n">status</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">        <span class="k">asm</span> <span class="k">volatile</span><span class="p">(</span>
</span><span class="line">            <span class="cm">/* Move the lock&#39;s address in the critical section flag. */</span>
</span><span class="line">            <span class="s">&quot;0: movq %[lock], %[critical_section]</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="cm">/* Do we still own the lock? */</span>
</span><span class="line">            <span class="s">&quot;cmpq %[owner], %[snapshot]</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="s">&quot;jne 1f</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="cm">/* Were we asked to cancel? */</span>
</span><span class="line">            <span class="s">&quot;cmpl %[cancelled], %[seq]</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="s">&quot;je 1f</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="cm">/* Success path! Set status to 0. */</span>
</span><span class="line">            <span class="s">&quot;xorl %[status], %[status]</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="cm">/* Store the value in *dst. */</span>
</span><span class="line">            <span class="s">&quot;movq %[value], %[dst]</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="cm">/* End of critical section. */</span>
</span><span class="line">            <span class="s">&quot;1:</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">
</span><span class="line">            <span class="cm">/*</span>
</span><span class="line"><span class="cm">             * Make sure the signal handler knows where the</span>
</span><span class="line"><span class="cm">             * critical section code begins &amp; ends.</span>
</span><span class="line"><span class="cm">             */</span>
</span><span class="line">            <span class="s">&quot;.pushsection rlock_store_list, </span><span class="se">\&quot;</span><span class="s">a</span><span class="se">\&quot;</span><span class="s">, @progbits</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="s">&quot;.quad 0b, 1b</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">            <span class="s">&quot;.popsection</span><span class="se">\n\t</span><span class="s">&quot;</span>
</span><span class="line">                <span class="o">:</span> <span class="p">[</span><span class="n">status</span><span class="p">]</span> <span class="s">&quot;+a&quot;</span><span class="p">(</span><span class="n">status</span><span class="p">),</span>
</span><span class="line">                  <span class="p">[</span><span class="n">critical_section</span><span class="p">]</span> <span class="s">&quot;+m&quot;</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">critical_section</span><span class="p">),</span>
</span><span class="line">                  <span class="p">[</span><span class="n">dst</span><span class="p">]</span> <span class="s">&quot;=m&quot;</span><span class="p">(</span><span class="o">*</span><span class="n">dst</span><span class="p">)</span>
</span><span class="line">                <span class="o">:</span> <span class="p">[</span><span class="n">lock</span><span class="p">]</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">lock</span><span class="p">),</span>
</span><span class="line">                  <span class="p">[</span><span class="n">snapshot</span><span class="p">]</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">snapshot</span><span class="p">.</span><span class="n">bits</span><span class="p">),</span>
</span><span class="line">                  <span class="p">[</span><span class="n">owner</span><span class="p">]</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">.</span><span class="n">bits</span><span class="p">),</span>
</span><span class="line">                  <span class="p">[</span><span class="n">seq</span><span class="p">]</span> <span class="s">&quot;r&quot;</span><span class="p">((</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">seq</span><span class="p">.</span><span class="n">sequence</span><span class="p">),</span>
</span><span class="line">                  <span class="p">[</span><span class="n">cancelled</span><span class="p">]</span> <span class="s">&quot;m&quot;</span><span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cancel_sequence</span><span class="p">),</span>
</span><span class="line">                  <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="s">&quot;r&quot;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class="line">                <span class="o">:</span> <span class="s">&quot;memory&quot;</span><span class="p">,</span> <span class="s">&quot;cc&quot;</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* Clear the flag. */</span>
</span><span class="line">        <span class="n">ck_pr_store_ptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">critical_section</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* Acknowledge any cancellation request. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="n">update_self</span><span class="p">(</span><span class="n">self</span><span class="p">);</span>
</span><span class="line">                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* Force lock reacquisition after a couple thousand writes. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">UNLIKELY</span><span class="p">(</span><span class="n">op_count</span> <span class="o">&gt;=</span> <span class="n">OP_LIMIT</span><span class="p">))</span> <span class="p">{</span>
</span><span class="line">                <span class="n">self</span><span class="o">-&gt;</span><span class="n">op_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">                <span class="n">rlock_owner_release</span><span class="p">();</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Finally, the signal handler for rlock cancellation requests iterates
through the <code>rlock_store_list</code> section until it finds a record that
strictly includes the instruction pointer.  If there is such a record,
the thread is in a critical section, and we can skip it by overwriting
<code>RIP</code> (to the end of the critical section) and setting <code>RAX</code> to 1.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span>"rlock.c" </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class="c"><span class="line"><span></span><span class="kt">void</span>
</span><span class="line"><span class="nf">rlock_signal_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signal</span><span class="p">,</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
</span><span class="line"><span class="p">{</span>
</span><span class="line">        <span class="n">ucontext_t</span> <span class="o">*</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>
</span><span class="line">        <span class="n">mcontext_t</span> <span class="o">*</span><span class="n">mctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">uc_mcontext</span><span class="p">;</span>
</span><span class="line">        <span class="k">struct</span> <span class="n">rlock_owner</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">rlock_self</span><span class="p">;</span>
</span><span class="line">        <span class="kt">uintptr_t</span> <span class="n">rip</span><span class="p">;</span>
</span><span class="line">        <span class="kt">size_t</span> <span class="n">nloc</span> <span class="o">=</span> <span class="n">__stop_rlock_store_list</span> <span class="o">-</span> <span class="n">__start_rlock_store_list</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">signal</span><span class="p">;</span>
</span><span class="line">        <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">info</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">        <span class="n">rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">mctx</span><span class="o">-&gt;</span><span class="n">gregs</span><span class="p">[</span><span class="n">REG_RIP</span><span class="p">];</span>
</span><span class="line">        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nloc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="k">struct</span> <span class="n">rlock_store</span> <span class="n">record</span><span class="p">;</span>
</span><span class="line">
</span><span class="line">                <span class="n">record</span> <span class="o">=</span> <span class="n">__start_rlock_store_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class="line">                <span class="k">if</span> <span class="p">(</span><span class="n">rip</span> <span class="o">&lt;</span> <span class="n">record</span><span class="p">.</span><span class="n">begin</span> <span class="o">||</span> <span class="n">rip</span> <span class="o">&gt;=</span> <span class="n">record</span><span class="p">.</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                        <span class="k">continue</span><span class="p">;</span>
</span><span class="line">                <span class="p">}</span>
</span><span class="line">
</span><span class="line">                <span class="n">assert</span><span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class="line">
</span><span class="line">                <span class="cm">/* skip the critical instruction. */</span>
</span><span class="line">                <span class="n">mctx</span><span class="o">-&gt;</span><span class="n">gregs</span><span class="p">[</span><span class="n">REG_RIP</span><span class="p">]</span> <span class="o">=</span> <span class="n">record</span><span class="p">.</span><span class="n">end</span><span class="p">;</span>
</span><span class="line">                <span class="cm">/* set the interrupted flag. */</span>
</span><span class="line">                <span class="n">mctx</span><span class="o">-&gt;</span><span class="n">gregs</span><span class="p">[</span><span class="n">REG_RAX</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class="line">                <span class="k">return</span><span class="p">;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="cm">/* Might as well publish that we observed any cancellation request. */</span>
</span><span class="line">        <span class="k">if</span> <span class="p">(</span><span class="n">self</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">                <span class="n">ck_pr_fas_32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">acked_sequence</span><span class="p">,</span>
</span><span class="line">                    <span class="n">ck_pr_load_32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">cancel_sequence</span><span class="p">));</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">
</span><span class="line">        <span class="k">return</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="silly-benchmarks">Silly benchmarks</h2>

<p>On my 2.9 GHz Sandy Bridge, a baseline loop to increment a counter a
billion times takes 6.9 cycles per increment, which makes sense given
that I use inline assembly loads and stores to prevent any compiler
cleverness.</p>

<p>The same loop with an interlocked store (<code>xchg</code>) takes 36 cycles per
increment.</p>

<p>Interestingly, an <code>xchg</code>-based spinlock around normal increments only
takes 31.7 cycles per increment (0.44 IPC).  If we wish to back our
spinlocks with futexes, we must unlock with an interlocked write; releasing
the lock with a compare-and-swap brings us to 53.6 cycles per
increment (0.30 IPC)!  Atomics really mess with pipelining: unless
they’re separated by dozens or even hundreds of instructions, their
barrier semantics (that we usually need) practically forces an
in-order, barely pipelined, execution.</p>

<p>FWIW, 50ish cycles per transaction is close to what I see in
microbenchmarks for Intel’s RTM/HLE.  So, while the overhead of TSX is
non-negligible for very short critical sections, it seems more than
reasonable for adaptive locks (and TSX definitely helps when
preemption happens, as shown by Dice and Harris in
<a href="https://timharris.uk/papers/2016-lhp.pdf">Lock Holder Preemption Avoidance via Transactional Lock Elision</a>).</p>

<p>Finally, the figure that really matters: when incrementing with
<code>rlock_store_64</code>, we need 13 cycles per increment.  That loop hits
2.99 IPC, so I think the bottleneck is just the number of instructions
in <code>rlock_store_64</code>.  The performance even seems independent of the
number of worker threads, as long as they’re all on the same CPU.</p>

<p>In tabular form:</p>

<pre><code>| Method               | Cycle / increment | IPC  |
|----------------------|-------------------|------|
| Vanilla              |             6.961 | 1.15 |
| xchg                 |            36.054 | 0.22 |
| FAS spinlock         |            31.710 | 0.44 |
| FAS-CAS lock         |            53.656 | 0.30 |
| Rlock, 1 thd         |            13.044 | 2.99 |
| Rlock, 4 thd / 1 CPU |            13.099 | 2.98 |
| Rlock, 256 / 1       |            13.952 | 2.96 |
| Rlock, 2 / 2         |            13.047 | 2.99 |
</code></pre>

<p>Six more cycles per write versus thread-private storage really isn’t
that bad (accessing TLS in a shared library might add as much
overhead)… especially compared to 25-50 cycles (in addition to
indirect slowdowns from the barrier semantics) with locked
instructions.</p>

<p>I also have a statistics-gathering mode that lets me vary the fraction
of cycles spent in critical sections.  On my server, the frequency of
context switches between CPU-intensive threads scheduled on the same
CPU increases in steps until seven or eight threads; at that point,
the frequency tops out at one switch per jiffy (250 Hz).  Apart from
this scheduling detail, evictions act as expected (same
logic as for sampled profiles).  The number of evictions is almost
equal to the number of context switches, which is proportional to the
runtime.  However, the number of hard evictions (with the victim in a
critical section) is always proportional to the number of critical
section executed: roughly one in five million critical section is
preempted.  That’s even less than the one in two million we’d expect
from the ~six cycle per critical section: that kind of makes sense
with out of order execution, given that the critical section should
easily flow through the pipeline and slip past timer interrupts.</p>

<h2 id="trade-offs">Trade-offs</h2>

<p>The main trade-off is that rlocks do not attempt to handle thread
migrations: when a thread migrates to another CPU, we let it assume
(temporary) exclusive ownership of its pseudo-per-CPU struct instead
of issuing IPIs.  That’s good for simplicity, and also – arguably –
for scaling.  The scaling argument is weak, given how efficient IPIs
seem to be.  However, IPIs feel like one of these operations for which
most of the cost is indirect and hard to measure.  The overhead isn’t
only (or even mostly) incurred by the thread that triggers the IPIs:
each CPU must stop what it’s currently doing, flush the pipeline,
switch to the kernel to handle the interrupt, and resume execution.  A
scheme that relies on IPIs to handle events like thread migrations
(rare, but happens at a non-negligible base rate) will scale badly to
really large CPU counts, and, more importantly, may make it hard to
identify when the IPIs hurt overall system performance.</p>

<p>The other important design decision is that rlocks uses signals
instead of cross-modifying code.  I’m not opposed to cross-modifying
code, but I cringe at the idea of leaving writable and executable
pages lying around just for performance.  Again, we could <code>mprotect</code>
around cross-modification, but <code>mprotect</code> triggers IPIs, and that’s
exactly what we’re trying to avoid.  Also, if we’re going to
<code>mprotect</code> in the common case, we might as well just <code>mmap</code> in
different machine code; that’s likely a bit faster than two <code>mprotect</code>
and definitely safer (I would use this <code>mmap</code> approach for revocable
multi-CPU locks à la Harris and Fraser).</p>

<p>The downside of using signals is that they’re more invasive than
cross-modifying code.  If user code expects any (async) signal, its
handlers must either mask the rlock signal away and not use rlocks, or
call the rlock signal handler… not transparent, but not exacting
either.</p>

<p>Rlocks really aren’t that much code (560 LOC), and that code is fairly
reasonable (no mprotect or self-modification trick, just signals).
After more testing and validation, I would consider merging them in
<a href="http://concurrencykit.org/">Concurrency Kit</a> for production use.</p>

<p>Next step: either <code>mmap</code>-based strict revocable locks for non-blocking
concurrent code, or a full implementation of pseudo-per-CPU data based
on relaxed rlocks.</p>
</div>


  <footer class="page-footer">
    <p class="meta">
      
<span class="byline author vcard">Text authored by <span class="fn">Paul Khuong</span></span>


      





June
  
5th, 
2017




      
      

<br><span class="categories">
  In categories:
  
    AsymmetricSynchronisation
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
      
      
        <a class="basic-alignment left" href="/Blog/2017/04/02/three-universal-hashing-in-four-instructions/" title="Previous Post: Three-universal hashing in four instructions">&laquo; Three-universal hashing in four instructions</a>
      
      
      
      
        <a class="basic-alignment right" href="/Blog/2017/06/17/chubanovs-projection-methods-for-0-slash-1-programming/" title="Next Post: Chubanov's projection methods for 0/1 programming">Chubanov's projection methods for 0/1 programming &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>


</div>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Website copyright &copy; 2021 - <a href="mailto:pvk@pvk.ca">Paul Khuong</a> | <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/TheChymera/Koenigspress">Königspress</a></span>
</p>

</footer>
  

<script id="dsq-count-scr" src="//pvk.disqus.com/count.js" async></script>

  
<script type="text/javascript">
  var disqus_config = function () {
      this.page.url = 'https://www.pvk.ca/Blog/2017/06/05/relaxed-revocable-locks-mutual-exclusion-modulo-preemption/';
      this.page.identifier = 'https://www.pvk.ca/Blog/2017/06/05/relaxed-revocable-locks-mutual-exclusion-modulo-preemption/';
      this.page.title = 'Relaxed revocable locks: mutual exclusion modulo preemption';
  };

  (function() {
      var d = document, s = d.createElement('script');

      s.src = '//pvk.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
  })();
</script>












<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-20468541-1', 'auto');
  ga('send', 'pageview');
</script>



</body>
</html>
